#from UIX_1st import UIManager
from UIX_4th import UIManager
from thermobeacon_manager_nb import ThermoBeaconManagerNB
from nb_servo_node_client import NBServoNodeClient
from core.control_model import ControlModel
from pwa_ble_bridge import PWABLEBridge
import time

# ========= CONFIG =========

DEBUG_UI = False
DEBUG_SENSORS = False
DEBUG_BLE = False

# MACs for your two servo nodes
NODE0_MAC = b'92901cdb5110'  # upstream: Saloon flap
NODE1_MAC = b'7ea81cdb5110'  # downstream: Galley/Berth split

# ========= INIT =========

print("=" * 60)
print("Cabin Air Controller: bring-up test")
print("=" * 60)

# Create BLE servo node clients
servo_nodes = [
    NBServoNodeClient(mac_hex=NODE0_MAC, debug=DEBUG_BLE),
    NBServoNodeClient(mac_hex=NODE1_MAC, debug=DEBUG_BLE),
]

# Start their internal machines if they need an explicit start/connect bootstrap
for i, node in enumerate(servo_nodes):
    try:
        if hasattr(node, "start"):
            node.start()
        print(f"[INIT] Servo node {i} started")
    except Exception as e:
        print(f"[INIT] Servo node {i} start() error:", e)

# Shared control model for UI + remote bridges
control_model = ControlModel()

# Create ThermoBeacon manager (non-blocking version)
sensors = ThermoBeaconManagerNB(debug=DEBUG_SENSORS)

# Create UI
ui = UIManager(debug=DEBUG_UI, model=control_model)

# BLE bridge for PWA clients
pwa_bridge = PWABLEBridge(control_model, debug=DEBUG_BLE)

# Check if servo nodes are scanning at startup
nodes_scanning_at_startup = any(node.is_scanning() for node in servo_nodes)
if nodes_scanning_at_startup:
    print("[INIT] Servo nodes scanning - PWA advertising will be paused briefly")

# Always start the bridge (cleans up stale connections)
pwa_bridge.start()

# Pause immediately if servos are scanning
if nodes_scanning_at_startup:
    pwa_bridge.pause_advertising()

print("[INIT] Setup complete. Entering main loop.")


# ========= HELPERS =========

def _send_servo_targets_to_nodes(pending, servo_nodes):
    """
    pending looks like:
        {
          "node1_saloon_angle": <0-90>,
          "node2_split_angle":  <0-90>,
        }

    We'll try to deliver:
      - node1_saloon_angle -> servo_nodes[0]
      - node2_split_angle  -> servo_nodes[1]

    We use queue_angle() if available. If not, will fall back to send_angle_with_retry.
    """
    if not pending:
        return

    # Extract targets
    angle0 = pending.get("node1_saloon_angle", None)
    angle1 = pending.get("node2_split_angle",  None)

    # Helper to safely call an angle send on a node
    def _try_send(node, which, angle):
        if angle is None:
            return
        # clamp angle to physical range
        if angle < 0: angle = 0
        if angle > 90: angle = 90

        if node is None:
            print(f"[BLE] Node {which} missing, skipping")
            return

        # Only send if we think node is connected/healthy-ish
        ok = True
        if hasattr(node, "connection_ok"):
            ok = node.connection_ok()

        if not ok:
            print(f"[BLE] Node {which} not healthy, skipping angle {angle}")
            return

        # Prefer queue_angle if we have it (non-blocking-ish)
        if hasattr(node, "queue_angle"):
            print(f"[BLE] -> queue_angle({angle}) to node {which}")
            try:
                node.queue_angle(angle)
            except Exception as e:
                print(f"[BLE] queue_angle error on node {which}:", e)
            return

        # If we get here we don't know how to command this node
        print(f"[BLE] No known angle API for node {which}, skipping")

    # node0 = upstream flap (Saloon distribution)
    _try_send(servo_nodes[0] if len(servo_nodes) > 0 else None,
              "upstream",
              angle0)

    # node1 = downstream flap (Galley vs Berth split)
    _try_send(servo_nodes[1] if len(servo_nodes) > 1 else None,
              "downstream",
              angle1)


# ========= MAIN LOOP =========

while True:
    # 1. TOUCH/UI FIRST
    # ui.tick() will:
    #   - read touch
    #   - update bar visuals
    #   - update mode / priority / enabled flags
    #   - update footer
    #   - set ui.interaction_active and ui.recommended_sleep
    #   - keep saloon_share / berth_share in sync with drags
    ui.tick(sensors, servo_nodes)

    # 2. SERVO BLE MGMT + 3. TEMP/BEACONS
    # Coordinate all central scanning (servo + ThermoBeacon) vs peripheral advertising
    # The BLE adapter can only do ONE thing at a time: scan OR advertise
    # Strategy: Always stop advertising before ticking, then restart after if nothing is scanning
    if not ui.interaction_active:
        # Stop advertising before any central operations (scanning might happen during tick)
        pwa_bridge.pause_advertising()

        # Tick servo nodes (may start scanning)
        for node in servo_nodes:
            try:
                node.tick()
            except Exception as e:
                print("[BLE] servo tick() error:", e)

        # Tick ThermoBeacon scanner (may start scanning)
        try:
            sensors.tick()
        except Exception as e:
            print("[TB] sensors.tick() error:", e)

        # Check if anything is still scanning after ticks complete
        servos_scanning = any(node.is_scanning() for node in servo_nodes)
        try:
            tb_scanning = sensors.is_scanning()
        except Exception:
            tb_scanning = False

        # Only resume advertising if nothing is actively scanning
        if not servos_scanning and not tb_scanning:
            pwa_bridge.resume_advertising()

        # Refresh servo indicator visuals now that nodes have ticked
        ui.refresh_servo_health(servo_nodes)

    # 3.5 PWA BLE bridge (keeps advertising / notifications lightweight)
    try:
        # Update sensor data from ThermoBeacons
        pwa_bridge.update_sensors(sensors)

        # Tick the bridge (handles advertising, connections, notifications)
        pwa_bridge.tick(interaction_active=ui.interaction_active)
    except Exception as e:
        print("[PWA] bridge.tick() error:", e)

    # 4. COMMIT ANY SERVO TARGETS (user finished a drag and cooled down)
    pending = ui.get_pending_servo_targets_if_ready()
    if pending:
        # Actually send commands to nodes now ðŸš€
        _send_servo_targets_to_nodes(pending, servo_nodes)

    # 5. Sleep based on UI pacing (fast during drag, slower otherwise)
    # NOTE: In your current testing you commented sleep out.
    # Let's put it back because touch code often likes short sleeps,
    # not busy loops that starve I2C.
    time.sleep(ui.recommended_sleep)

